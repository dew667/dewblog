---
title: Java常见基础知识
---

### 1.面向对象和面向过程的区别

-   面向过程相较面向对象通常资源开销较小，性能更占优势。因为面向对象中类的调用需要实例化。通常用在嵌入式、底层开发等对资源占用或性能要求较高的场合。
    
-   面向对象更加易于维护、扩展和复用，因为面向对象加入了封装、继承、多态等特性。面向对象语言可以设计出更加灵活、易于维护和扩展的系统。
    
 <!--more-->
### 2.Java语言的特点

1.  易用 Java语言摒弃了C++中一些让人易迷惑的特性和语法，语言更加容易掌握
    
2.  面向对象 封装、继承、多态
    
3.  Java虚拟机让Java语言具有平台无关性
    
4.  安全
    
5.  支持网络编程 Java中具有这方面的类库
    
6.  支持多线程 Java本身具有多线程功能，无需调用操作系统的多线程API
    
7.  可靠性
    
8.  编译与解释并存
    

### 3.JVM、JRE和JDK

-   JVM  
    JVM即Java虚拟机，它是用来运行Java字节码的。Java字节码.class文件是.java源文件经过javac工具编译后得到的。JVM则读取.class字节码文件，通过解释器解释执行命令。也就是说，Java语言通过JVM实现了解释型语言的跨平台特性，并且通过.class文件实现了速度上的提高，能够做到一次编译，随处执行。在JVM的发展过程中出现了JIT，通过保存热点代码的机器码实现了运行速度的提高。
    
-   JRE和JDK
    
    1.  JDK即Java Development Kit，它包含了JRE的全部内容和javac编译工具以及javadoc等辅助工具。
        
    2.  JRE是Java运行时环境。Java Runtime Environment，它是机器运行Java程序的基本工具。
        
    3.  如果要开发基于Java的程序，则需要安装JDK，如果只是用来运行Java程序，则只需安装JRE。但并不绝对，比如在运行基于JSP的服务端程序时，需要安装JDK，因为JSP代码需要用到JDK编译Servlet程序。
        

### 4.OracleJDK和OpenJDK

1.  OpenJDK是免费开源的，而OracleJDK并不是完全开源的。
    
2.  OracleJDK和OpenJDK的代码基本相同，有大量重合的部分.
    
3.  OracleJDK的稳定性和JVM性能要优于OpenJDK。
    

### 5.Java和C++的区别

1.  Java和C++都是面向对象语言，都具有封装、继承、多态特性。
    
2.  Java不支持通过指针访问内存，程序内存更加安全
    
3.  Java的类不支持多继承，而C++支持多继承，但是Java中接口可以多继承
    
4.  Java提供了自动内存管理机制，不需要手动释放无用的内存
    
5.  C++中字符数组和字符串都以”\\0”标记结尾,而Java中没有这一概念
    

### 6.字符型常量和字符串常量的区别

-   字符型常量是单引号引起的一个字符，而字符串常量是双引号引起的若干字符。
    
-   字符型常量相当于一个整型值，可以参与运算(ASCII码)，字符串常量相当于一个地址，保存该字符串在内存中的位置。
    
-   字符型常量占2字节，字符串常量占若干字节.
    

### 7.Java基本类型的大小

基本类型

大小

最小值

最大值

包装类型

boolean

Boolean

byte

8 bits

\-128

127

Byte

char

16 bits

Character

void

Void

short

16 bits

\-2E15

2E15-1

Short

int

32 bits

\-2E31

2E31-1

Integer

long

64 bits

\-2E63

2E63-1

Long

float

32 bits

1.4E-45

3.4E38

Float

double

64 bits

1.80E308

4.9E-324

Double

### 8.构造器Constructor是否可被override？

Constructor不能被重写（Override），但可以重载（Overload），所以可以见到一个类中有多个构造函数的情况。

### 9.重载和重写的区别

-   重载是一个类中多态特性的体现。即同名的方法根据传入参数的不同而具有不同的反应。重载方法可以具有不同的参数列表、参数顺序，也可以具有不同的访问修饰符和返回值类型。但是需要注意的是不允许出现这样的重载方法：方法名相同，参数列表相同但是仅仅返回值类型不同。
    
-   重写是类继承中多态特性的体现。即子类对父类中的方法进行覆盖，具有不同的实现过程。重写要求子类中的重写方法与父类被重写的方法具有相同的参数列表，返回值类型只能范围更小，访问修饰符范围更大，抛出异常类型范围更小。
    

### 10.Java面向对象三大特性：封装、继承、多态

-   封装  
    封装是将类的属性私有化，不允许外部直接使用这些属性，而提供一些方法让外部间接调用这些属性。
    
-   继承  
    继承是指继承一个类的属性和方法的技术，子类可以继承父类的属性的方法，并且可以添加自己的属性和方法，以及重写父类中的方法。继承可以使得代码可以较好地复用。
    
-   多态  
    多态是指同一个行为具有不同地表现形式或形态大的能力。多态分为重载式多态和重写式多态。重载即同名的方法根据传入参数的不同执行不同的过程。在Java中表现为重载方法，是一种编译时多态。而重写式多态是一种运行时多态。在执行期判断引用对象的类型，从而执行相应的方法。
    

### 11.String StringBuilder和StringBuffer的区别是什么？String为什么是不可变的?

String类中使用final关键字修饰字符数组来保存字符串数据 private final char\[\] value 因而String对象是不可变的。  
StringBuilder和StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder类中字符串数据没有使用final关键字，因而这两种对象的字符串是可以改变的。  
StringBuilder中没有对方法加同步锁Synchronized，而StringBuffer中方法都加了同步锁。因而StringBuilder不是线程安全的，而StringBuffer是线程安全的。  
但是StringBuilder的性能要稍微由于StringBuffer。

### 12.自动拆箱与自动装箱

自动拆箱: 将基本类型包装为对应的引用类型。  
自动拆箱：将包装类型转换为基本数据类型。

### 13.在一个静态方法里调用一个非静态成员为什么是非法的？

静态方法属于该类的所有对象共有，而非静态成员属于某一对象所有。因而静态方法中调用非静态成员是不被允许的。

### 14.在Java中定义一个不做事且不带参数的构造方法的作用？

Java中如果子类构造方法中没有用`super()`去显式调用父类的某一构造方法，则会默认调用父类中没有参数的构造方法。如果父类中没有定义无参数的构造方法。则编译时会出错，因为找不到无参数的构造方法。所以我们可以去定义一个不做事且不带参数的构造方法填补缺位。

### 14.import java 和 javax 有什么区别？

最初JavaAPI所必须的包是java包，javax包只是用来扩展。但随着java语言的发展，javax包也成为javaAPI的组成部分。但是将javax包中的代码迁移到java包中十分麻烦，会破坏原有代码。因此就把javax包也纳入到标准API的一部分。

### 15.接口和抽象类的区别

1.  接口的方法修饰符为public(JDK9可以为private)，接口方法只能是空实现（JDK8开始可以有默认实现）。而抽象类的方法修饰符可以为public、private、protected和default。并且抽象类方法可以为抽象方法也可以有默认实现，即非抽象方法。
    
2.  接口中不能包含成员变量，只能是private static final 修饰的变量，而抽象类中可以有自己的成员变量。
    
3.  接口是对行为的抽象，是行为规范，而抽象类是对类的抽象，是模板设计。
    
4.  一个类可以实现多个接口，但只能继承一个抽象类。
    

### 16.成员变量与局部变量的区别有哪些？

1.  从归属上看，成员变量属于类或者实例，而局部变量存在于方法内部。成员变量可以被public、private、static等修饰符修饰，而局部变量不能被访问控制修饰符及static修饰。但是两者都可以被final关键字修饰。
    
2.  从生存周期上看，成员变量随着类的实例的创建而出生和消亡，而局部变量随着方法调用生存和消亡。
    
3.  从内存存储方式上看，成员变量如果有static修饰，则属于类，否则属于实例。而对象存在于堆内存，局部变量则存在于栈内存。
    
4.  成员变量如果没有被显式地赋初值，则会赋予类型默认值。（如果有final关键字修饰则例外）局部变量则必须显式地赋予初值。
    

### 17.创建一个对象用什么运算符？对象引用与对象实体有什么区别？

用new运算符。对象实体存在于堆内存中，而对象引用存在于栈内存中。对象引用用来指向对象实体。一个对象引用可以不指向对象实体，也可以指向一个对象实体。而一个对象实体可以被多个对象引用所指。

### 18.什么是方法的返回值？返回值在类的方法里的作用是什么？

方法的返回值是一个方法执行后返回的结果。方法产生的返回值用于进行其他的操作。

### 19.一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？

类的构造方法的作用是完成初始化对象的工作。可以。因为这种情况会执行默认的不带参数的构造方法。

### 20.构造方法有哪些特性？

1.  名字与类名相同。
    
2.  不需显式调用，在生成对象时自动执行。
    
3.  没有返回值，不能声明返回值类型为void。
    

### 21.静态方法和实例方法有何不同？

静态方法可以用类名.方法名或者对象名.方法名的方式调用，而实例方法只能用后一种方式。也就是说，静态方法可以不通过创建对象实例的方式去调用，静态方法为类的所有对象所共有。  
静态方法中只能调用静态成员，即静态属性和静态方法，而实例方法不受此限制。

### 22.对象的相等与指向他们的引用相等，两者有什么不同？

对象的相等，比的是内存中的存放内容是否相等，而引用相等，指的是他们指向的内存地址是否相等。

### 23.在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？

帮助子类进行初始化工作。

### 24.==和equals

-   如果是基本类型，==比较的是值是否相等；如果是引用类型，==比较的是指向的内存地址是否相同。
    
-   如果类中没有重写equals方法，则equals采用Object类中的方法，即比较内存地址是否相同。如果类中重写了equals方法，例如String类那样，则比较的是内容值是否相等。
    
        public calss Example {
            public static void main(String[] args) {
                String a = new String("abc");
                String b = new String("abc");
                if(a == b) { // false
                    System.out.println("a==b");
                }
                if(a.equals(b)) { // true
                    System.out.println("a equals b");
                }
                
                String a1 = "abc";
                String b1 = "abc";
                if(a1 == b1) { // true
                    System.out.println("a1==b1");
                }
                if(a1.equals(b1)) { // true
                    System.out.println("a1 equals b1");
                }
            }
        }
    

### 25.hashCode()和equals

-   什么是hashCode?  
    hashCode即哈希码。它是用来在散列表中确定元素的索引位置的一种码。在散列表中，我们通过键值快速查询到对应元素就用到了哈希码。
    
-   介绍hashCode()哈希函数  
    hashCode()只在使用散列表时有作用。hashCode()函数就是用来生成哈希码的函数。hashCode()在Object类中存在，因此所有的类都有hashCode()函数。
    
-   为什么要有hashCode？  
    因为在诸如HashMap、HashSet、HashTable等Java集合类中本质是用到了散列表，通过hashcode来实现快速定位其中的元素。
    
-   为什么重写equals时必须重写hashCode()方法？  
    因为在我们使用HashMap、HashSet、HashTable这类集合时，对其中的元素要计算其hashCode哈希码。两个相同的对象，其hashcode一定要相同。如果我们不重写hashCode()方法，那么两个对象虽然用equals比较时是相同的，但hashcode却不同，这样就产生了矛盾，在使用上述集合类时也会产生错误。
    

* * *

**参考**

\[1\] JavaGuide面试突击版[https://gitee.com/SnailClimb/JavaGuide](https://gitee.com/SnailClimb/JavaGuide)