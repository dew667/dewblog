---
title: Java常见基础知识(续)
---

### 26.为什么Java中只有值传递？

Java中方法采用是值传递而不是引用调用，即方法接收的是参数的一份拷贝。  
总结：

-   Java中方法不能修改一个基本数据类型的参数。
    
-   Java中方法可以改变一个对象参数的状态。
    
-   Java中方法不能让对象参数引用一个新的对象。
    
<!--more-->
### 27.简述程序、进程、线程的概念。以及它们之间的关系？

-   程序  
    程序可以定义为算法加数据，一个程序可以是存放在计算机存储空间中的代码集合，例如浏览器就是一个程序。
    
-   进程  
    计算机操作系统可以实现多任务功能。为了实现多任务，操作系统必须利用好CPU，可以通过CPU分时或者多核CPU来实现。而一个任务可以理解为一个进程。操作系统为一个进程分配一定的内存存储空间和CPU时间以及文件、设备的控制权。进程通过这些资源实现自己的任务功能。
    
-   线程  
    线程可以理解为一个进程中更细粒度的运行单位。一个进程可以通过多个线程同时执行多个子功能模块。多个线程共享进程的内存存储空间、系统资源，因而线程之间通信和切换等操作比较方便。
    
-   进程、线程之间的关系  
    进程是操作系统执行多任务的基本运行单位，而线程是进程内更细粒度的基本运行单位。操作系统为进程分配内存存储空间、CPU时间、文件和设备控制器等资源，进程内部的线程共享该进程的内存存储空间等资源。线程之间通信和切换操作相较进程之间更加方便。
    

### 28.线程有哪些基本状态？

1.  Java中线程的基本状态有NEW、RUNNABLE、WAITING、TIMED\_WAITING、BLOCKED、TERMINATED。即初始状态、运行状态、等待状态、超时等待状态、阻塞状态、终止状态。
    

状态

名称

描述

NEW

初始状态

线程被创建但还未调用start()方法

RUNNABLE

运行状态

Java中将就绪状态和运行状态笼统地称为RUNNABLE状态

WAITING

等待状态

线程等待其他线程的通知

TIMED\_WAITING

超时等待状态

等待一段时间线程可以自行回到RUNNABLE状态

BLOCKED

阻塞状态

线程执行同步方法时，未获取到锁则进入阻塞状态

TERMINATED

终止状态

线程执行结束

![java线程](https://s1.ax1x.com/2020/04/10/GoY9Og.png)

> 线程创建之后，进入NEW状态，即初始状态。调用start()方法后线程进入READY状态(就绪状态)，当分配到CPU时间片后，即进入RUNNING状态(运行)。在Java中，把READY和RUNNING状态笼统地称为RUNNABLE状态。如果线程执行wait()方法，则线程进入WAITING状态(等待状态)。在此状态下只有其它线程通知，才能回到运行状态。TIMED\_WAITING状态(超时等待状态)则是在WAITING状态基础上加上时间限制，例如sleep(long)，当时间到后线程回到运行状态。如果线程要调用同步方法而没有获取到锁，则进入BLOCKED(阻塞状态)。在此状态下如果获取到锁则回到运行状态。线程执行完毕，进入TERMINATED状态(终止状态)。

### 29.关于final关键字的一些总结

final关键字用法有三种：用于变量、用于类、用于方法。

1.  final关键字用于变量  
    final用于基本数据类型变量时，变量一旦被初始化就不能再修改。如果用于引用类型变量，则引用类型变量一旦初始化对象后就不能再更改引用指向。
    
2.  final关键字用于类  
    final关键字用于类时，表明该类不能被继承。另外，final关键字修饰的类中的方法都隐式地指定为final
    
3.  final关键字用于方法  
    final关键字用于方法，则该方法不能被子类重写。private修饰的方法都被隐式地指定为final。
    

### 30.Java异常处理

-   Java异常结构层次  
    ![Java异常处理](https://s1.ax1x.com/2020/04/10/GoYiwj.png)
    
-   Java异常处理  
    Java中所有异常都有一个共同的祖先，即java.lang包中的Throwable类。Thorwable有两个重要的子类Error和Exception。Error是程序无法处理的错误，一般是程序运行时JVM发生的错误，如内存用尽时OutOfMemoryError。Exception是程序可以处理的异常，如要访问的变量没有引用任何对象时NullPointerException。  
    Error和Exception之间的不同之处是Error是程序本身不可以处理的错误，而Exception是程序本身可以处理的异常。
    
-   Throwable类常用方法
    
    1.  public String getMessage() 返回异常发生时的简要描述
        
    2.  public String toString() 返回异常发生时的详细信息
        
    3.  public void printStackTrace() 在控制台上打印Throwable对象封装的异常信息
        
-   Try-Catch块的使用  
    try块用于捕获异常，其后可接一个或多个catch块。如果没有接catch块，则其后必须接finally块。  
    catch块用于处理异常。  
    finally块：无论是否捕获或处理异常，finally块中的语句都会被执行。如果在之前try块或catch块中已有return语句，则finally块中的内容会在return之前先执行。如果不仅try块中有return语句，而且finally块中也有return语句，则返回前先执行finally块内容，finally块中的return语句代替try中return。
    
-   不会执行finally块的情况
    
    1.  finally块中第1行语句发生异常。
        
    2.  前面已用System.exit(int)退出程序
        
    3.  所在线程死亡
        
    4.  CPU关闭
        

### 31.Java序列化中如果有些字段不想序列化，怎么办？

对实例中不想进行序列化的字段使用transient关键字修饰。  
transient关键字只能修饰变量，不能修饰类和方法。

### 32.获取键盘输入常用的方法？

-   Scanner
    

    Scanner input = new Scanner(System.in);
    String s = input.nextLine();
    input.close();

-   BufferedReader
    

    BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
    String s = input.readLine();

### 33.Java中IO流分为几种？

-   分类
    
    1.  按照方向分为输入流和输出流
        
    2.  按照操作单位分为字符流和字节流
        
    3.  按照流的角色分为节点流和处理流
        
-   为什么有了字节流还要有字符流  
    因为字符流是Java虚拟机通过字节流转换而来的，转换过程比较费时而且不知道编码的情况下容易乱码，所以Java索性提供了字符流接口。
    

### 34.BIO、NIO、AIO有什么区别?

-   BIO  
    BIO是指同步阻塞IO模式。这种模式下，数据操作必须阻塞在一个线程内等待其完成。即需要维持一个连接，而且客户端不能做其他事情。BIO模式的优点是使用起来直观、简单，能够应对并发量较小的情况。缺点是，当并发量过大时服务器负担较大，无法很好地应对。
    
-   NIO  
    NIO是指同步非阻塞IO模式。这种模式下，客户端与服务端之间不需要保持一个连接，而是分成许多小的连接。客户端向服务端轮询，如果没有数据则断开连接，直到有数据为止。客户端与服务端不需要维持连接，客户端也不可以做其他事情。NIO模型相较BIO能够更好地应对高负载、高并发的情况。
    
-   AIO  
    AIO是指异步非阻塞IO模型。在这种模式下，客户端与服务端之间不用保持连接，也不用轮询方式。而是在服务端处理完成后能够通知客户端并返回数据。客户端在得到数据之前可以做其他事情。目前来说，AIO应用并不广泛。
    

### 35.常见关键字总结：final、static、this、super

-   final  
    final关键字主要可以用在三个地方:变量、类、方法.
    
    -   final关键字用于变量： final关键字如果用于基本数据类型的变量，则该变量一旦初始化，就不可以修改其值；如果用于引用类型变量，则一旦该变量初始化，就不可以改变引用对象。
        
    -   final关键字用于类： final关键字用于类，表明该类不可以被继承。并且final关键字修饰的类，其中的方法隐式地被修饰final关键字。
        
    -   final关键字用于方法： final关键字修饰方法，主要有两个作用。一是表明该方法不可被子类重写。二是在早期Java版本中，使用内嵌调用方式以提高性能。
        
-   static  
    static关键字可以用在四个地方：修饰类的成员、静态代码块、修饰内部类、静态导包
    
    -   static关键字用于修饰类的成员： static修饰类的成员时，这些成员属于类而不属于类的实例对象，可以用类名.成员名的方式访问这些成员。如果static修饰的是成员变量，则成员变量存放在内存方法区中。如果static修饰的是成员方法，则在该方法内只能访问static修饰的变量或方法。
        
    -   static关键字用于静态代码块： 静态代码块是在非静态代码块之前执行，且对于一个类的所有实例对象只执行一次。
        
    -   static关键字用于内部类： static修饰内部类，则该内部类不具有外部类的引用，因此该内部类的创建不需要依赖外部类，同时该内部类只能访问外部类的static修饰的成员。
        
    -   static关键字用于静态导包： 静态导包可以不需要通过类名来访问其中的成员。
        
-   this  
    this关键字用于引用类的当前实例。
    
-   super  
    super关键字用于子类访问父类的成员。
    

### 36.深拷贝和浅拷贝

拷贝一个对象时分为深拷贝和浅拷贝

-   浅拷贝  
    浅拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，而拷贝引用类型则只是对引用进行传递，因此拷贝前后两个对象中的引用类型仍然指向同一个对象，对两个对象中引用对象的数据进行修改会相互影响。
    
-   深拷贝  
    深拷贝是指拷贝时，对基本数据类型的拷贝以值传递方式进行，并且拷贝引用类型变量时新建一个对象的空间并复制其中的内容。这样两个对象中引用的对象不是同一个。
    
-   浅拷贝和深拷贝的一种实现方式是类实现Cloneable接口，并且重写clone()方法。如果要做到深拷贝，则引用类型也需要实现Cloneable接口并重写clone()方法。
    

**参考**

\[1\] JavaGuide面试突击版\[[https://gitee.com/SnailClimb/JavaGuide\]](https://gitee.com/SnailClimb/JavaGuide])(